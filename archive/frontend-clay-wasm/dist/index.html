<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Task Tracker</title>
    <style>
        * {
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            padding: 0;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body > canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        .input-overlay {
            position: absolute;
            background: transparent;
            border: none;
            outline: none;
            font-family: inherit;
            font-size: 14px;
            padding: 10px 12px;
            opacity: 0;
            pointer-events: none;
        }
        .input-overlay.active {
            opacity: 1;
            pointer-events: auto;
            background: #fafafc;
            border: 1px solid #dcdce6;
            border-radius: 6px;
        }
        .modal-overlay {
            position: fixed;
            left: 220px;
            right: 0;
            bottom: 0;
            height: 33vh;
            z-index: 1000;
        }
        .modal-overlay.hidden {
            display: none;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at top, rgba(245,245,250,0.96), rgba(230,233,242,0.98));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1200;
        }
        .loading-overlay.hidden {
            display: none;
        }
        .loading-panel {
            background: rgba(255,255,255,0.92);
            border: 1px solid #dcdce6;
            border-radius: 12px;
            padding: 22px 26px;
            width: 520px;
            max-width: 90%;
            box-shadow: 0 10px 28px rgba(0,0,0,0.08);
        }
        .loading-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #222;
        }
        .loading-tip {
            font-size: 14px;
            color: #444;
            line-height: 1.4;
        }
        .modal-content {
            background: white;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            border: 1px solid #dcdce6;
            border-bottom: none;
            padding: 20px 24px;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            box-shadow: 0 -10px 24px rgba(0,0,0,0.08);
        }
        .modal-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 16px;
        }
        .form-label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 6px;
        }
        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            font-size: 14px;
            border: 1px solid #dcdce6;
            border-radius: 6px;
            background: #fafafc;
        }
        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }
        .form-row {
            display: flex;
            gap: 12px;
        }
        .form-row .form-group {
            flex: 1;
        }
        .service-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #fff;
            border: 1px solid #dcdce6;
            border-radius: 6px;
            margin-top: 6px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.08);
            z-index: 10;
            max-height: 220px;
            overflow-y: auto;
        }
        .service-suggestions.hidden {
            display: none;
        }
        .service-suggestion {
            padding: 10px 12px;
            cursor: pointer;
            font-size: 14px;
        }
        .service-suggestion:hover {
            background: #f5f5fa;
        }
        .service-field {
            position: relative;
        }
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }
        @media (max-width: 900px) {
            .modal-overlay {
                left: 0;
                right: 0;
                height: 45vh;
            }
        }
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            border: none;
        }
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        .btn-primary:hover {
            background: #2563eb;
        }
        .btn-secondary {
            background: #f5f5fa;
            color: #333;
            border: 1px solid #dcdce6;
        }
        .btn-secondary:hover {
            background: #eee;
        }
        #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999;
        }
        #login-overlay.hidden {
            display: none;
        }
        #login-username, #login-password {
            position: absolute;
            width: 336px;
            height: 44px;
        }

        /* Safe defaults (even if JS positioning fails) */
        #login-username {
            left: calc(50% - 168px);
            top: calc(50% - 56px);
        }
        #login-password {
            left: calc(50% - 168px);
            top: calc(50% + 8px);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-panel">
            <div class="loading-title">Warming up the workstation</div>
            <div class="loading-tip" id="loading-tip"></div>
        </div>
    </div>

    <!-- Login form overlay -->
    <div id="login-overlay">
        <input type="text" id="login-username" class="input-overlay active" placeholder="Username" autocomplete="username">
        <input type="password" id="login-password" class="input-overlay active" placeholder="Password" autocomplete="current-password">
    </div>

    <!-- Create/Edit Task Modal -->
    <div id="task-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="modal-title" id="modal-title">Create Task</div>
            <form id="task-form">
                <div class="form-group">
                    <label class="form-label">Title</label>
                    <input type="text" class="form-input" id="task-title" required>
                </div>
                <div class="form-group">
                    <label class="form-label">Description</label>
                    <textarea class="form-textarea" id="task-description"></textarea>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Status</label>
                        <select class="form-select" id="task-status">
                            <option value="0">Pending</option>
                            <option value="1">In Progress</option>
                            <option value="2">Completed</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Priority</label>
                        <select class="form-select" id="task-priority">
                            <option value="0">Low</option>
                            <option value="1">Medium</option>
                            <option value="2">High</option>
                            <option value="3">Urgent</option>
                        </select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Service</label>
                        <div class="service-field">
                            <input type="text" class="form-input" id="task-service" autocomplete="off" placeholder="Search services">
                            <div id="service-suggestions" class="service-suggestions hidden"></div>
                        </div>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Due Date</label>
                        <input type="date" class="form-input" id="task-due-date">
                    </div>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" id="cancel-btn">Cancel</button>
                    <button type="submit" class="btn btn-primary" id="submit-btn">Create</button>
                </div>
            </form>
        </div>
    </div>

<script type="module">
    // Clay render command types
    const CLAY_RENDER_COMMAND_TYPE_NONE = 0;
    const CLAY_RENDER_COMMAND_TYPE_RECTANGLE = 1;
    const CLAY_RENDER_COMMAND_TYPE_BORDER = 2;
    const CLAY_RENDER_COMMAND_TYPE_TEXT = 3;
    const CLAY_RENDER_COMMAND_TYPE_IMAGE = 4;
    const CLAY_RENDER_COMMAND_TYPE_SCISSOR_START = 5;
    const CLAY_RENDER_COMMAND_TYPE_SCISSOR_END = 6;
    const CLAY_RENDER_COMMAND_TYPE_CUSTOM = 7;

    const GLOBAL_FONT_SCALING_FACTOR = 1.0;

    // State
    let instance;
    let memoryDataView;
    let scratchSpaceAddress = 0;
    let heapSpaceAddress = 0;
    let cmdBufferAddress = 0;
    const CMD_BUFFER_BYTES = 1024 * 1024;
    let previousFrameTime = 0;
    let canvasPixelWidth = 0;
    let canvasPixelHeight = 0;
    let canvasScale = 1;

    // Perf HUD
    let hudEnabled = true;
    let hudFps = 0;
    let hudFpsMin = 999;
    let hudAccumMs = 0;
    let hudFrames = 0;
    let hudLastReportTime = 0;
    let hudWasmMs = 0;
    let hudDrawMs = 0;
    let hudCmds = 0;
    let hudTextCmds = 0;
    // Dev mode: backend accepts requests without auth for UI iteration.
    let authToken = null;
    let wsConnection = null;
    let appStatePtr = null;
    let taskInputPtr = null;
    let serviceInputPtr = null;
    let currentUserPtr = null;

    const textDecoder = new TextDecoder("utf-8");
    const textEncoder = new TextEncoder();

    // Font configuration
    const fontsById = [
        'system-ui, -apple-system, sans-serif',  // FONT_ID_BODY_16
        'system-ui, -apple-system, sans-serif',  // FONT_ID_BODY_20
        'system-ui, -apple-system, sans-serif',  // FONT_ID_TITLE_24
        'system-ui, -apple-system, sans-serif',  // FONT_ID_TITLE_32
    ];

    let services = [];
    let selectedServiceId = null;
    let wsReloadTimer = null;

    const loadingTips = [
        'Tip: Use the status filter in the left rail to keep your day focused.',
        'Tip: A short, clear task title makes search feel instant.',
        'Tip: Priorities are for sequencing; categories are for grouping.',
        'Tip: Due dates are for commitments, not wishes.',
        'Tip: If a task is stuck, add a one-line next action.',
        'Tip: Fast triage beats perfect triage. Capture first, refine later.',
        'Tip: Batch similar tasks to reduce context switching.',
        'Tip: Clear "In Progress" before starting new work. Momentum matters.',
        'Tip: A tiny description now saves a big re-read later.',
        'Tip: Assign a service to track who pays for the time.'
    ];

    // Packed render command stream produced by WASM (do not parse Clay structs from JS).
    const PACKED_HDR_SIZE = 16;
    const PACKED_CMD_SIZE = 64;

    const TASK_INPUT_HDR_SIZE = 16;
    // Task input entry layout matches frontend/main.c (TXXT_TASK_INPUT_STRIDE).
    const TASK_INPUT_STRIDE = 916;
    const TASK_TITLE_MAX = 128;
    const TASK_DESC_MAX = 512;
    const TASK_CATEGORY_MAX = 64;
    const TASK_SERVICE_NAME_MAX = 64;
    const TASK_DUE_DATE_MAX = 32;
    const TASK_ASSIGNED_TO_MAX = 64;
    const TASK_ID_MAX = 37;
    const TASK_INPUT_MAX = 100;

    const SERVICE_INPUT_HDR_SIZE = 16;
    const SERVICE_INPUT_STRIDE = 128;
    const SERVICE_ID_MAX = 37;
    const SERVICE_NAME_MAX = 64;
    const SERVICE_INPUT_MAX = 64;

    function getTextDimensions(text, font) {
        window.canvasContext.font = font;
        const metrics = window.canvasContext.measureText(text);
        return {
            width: metrics.width,
            height: metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent
        };
    }

    // API functions
    async function apiRequest(endpoint, options = {}) {
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };
        if (authToken) {
            headers['Authorization'] = `Bearer ${authToken}`;
        }

        const response = await fetch(`/api${endpoint}`, {
            ...options,
            headers
        });

        if (!response.ok) {
            if (response.status === 401) {
                authToken = null;
                localStorage.removeItem('auth_token');
                instance.exports.SetLoggedIn(false);
            }
            throw new Error(`API error: ${response.status}`);
        }

        return response.json();
    }

    async function login(username, password) {
        try {
            const data = await apiRequest('/auth/login', {
                method: 'POST',
                body: JSON.stringify({ username, password })
            });
            authToken = data.token;
            localStorage.setItem('auth_token', authToken);
            if (currentUserPtr) {
                writeFixedString(currentUserPtr, username, 64);
            }
            instance.exports.SetLoggedIn(true);
            document.getElementById('login-overlay').classList.add('hidden');
            await withDailyLoadingOverlay(async () => {
                await loadServices();
                await loadTasks();
            });
            connectWebSocket();
        } catch (err) {
            console.error('Login failed:', err);
            alert('Login failed. Please check your credentials.');
        }
    }

    async function loadServices() {
        try {
            const data = await apiRequest('/services');
            services = (data || []).slice().sort((a, b) => a.name.localeCompare(b.name));
            if (serviceInputPtr) {
                const count = Math.min(services.length, SERVICE_INPUT_MAX);
                memoryDataView.setUint32(serviceInputPtr + 0, count, true);
                memoryDataView.setUint32(serviceInputPtr + 4, SERVICE_INPUT_STRIDE, true);
                memoryDataView.setUint32(serviceInputPtr + 8, 0, true);
                memoryDataView.setUint32(serviceInputPtr + 12, 0, true);

                for (let i = 0; i < count; i++) {
                    const service = services[i];
                    const base = serviceInputPtr + SERVICE_INPUT_HDR_SIZE + (i * SERVICE_INPUT_STRIDE);
                    writeFixedString(base + 0, service.id || '', SERVICE_ID_MAX);
                    writeFixedString(base + 64, service.name || '', SERVICE_NAME_MAX);
                }

                instance.exports.ApplyServiceInputBuffer(count);
            }
        } catch (err) {
            console.error('Failed to load services:', err);
            services = [];
        }
    }

    async function withDailyLoadingOverlay(work) {
        const today = new Date().toISOString().slice(0, 10);
        const last = localStorage.getItem('txxt_tip_date');
        const overlay = document.getElementById('loading-overlay');
        const tip = document.getElementById('loading-tip');
        const show = overlay && tip && last !== today;

        if (show) {
            const choice = loadingTips[Math.floor(Math.random() * loadingTips.length)];
            tip.textContent = choice;
            overlay.classList.remove('hidden');
        }

        const minMs = 900;
        const start = performance.now();
        try {
            await work();
        } finally {
            if (show) {
                const elapsed = performance.now() - start;
                const wait = Math.max(0, minMs - elapsed);
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    localStorage.setItem('txxt_tip_date', today);
                }, wait);
            }
        }
    }

    function normalizeText(value) {
        return (value || '').toLowerCase().trim();
    }

    function scoreServiceMatch(query, name) {
        const q = normalizeText(query);
        const n = normalizeText(name);
        if (!q) {
            return 1;
        }

        let score = 0;
        if (n.includes(q)) {
            score += 100 + q.length * 2;
        }

        const tokens = q.split(/\s+/).filter(Boolean);
        for (const token of tokens) {
            if (n.includes(token)) {
                score += 10;
            }
        }

        let qi = 0;
        let gaps = 0;
        for (let i = 0; i < n.length && qi < q.length; i++) {
            if (n[i] === q[qi]) {
                qi++;
            } else if (qi > 0) {
                gaps++;
            }
        }
        if (qi === q.length) {
            score += 20 + Math.max(0, q.length * 2 - gaps);
        }

        return score;
    }

    function renderServiceSuggestions(query) {
        const list = document.getElementById('service-suggestions');
        if (!list) return;

        const matches = services
            .map((service) => ({ service, score: scoreServiceMatch(query, service.name) }))
            .filter((entry) => entry.score > 0 || !normalizeText(query))
            .sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                return a.service.name.localeCompare(b.service.name);
            })
            .slice(0, 6);

        list.innerHTML = '';

        if (!matches.length) {
            list.classList.add('hidden');
            return;
        }

        for (const entry of matches) {
            const item = document.createElement('div');
            item.className = 'service-suggestion';
            item.textContent = entry.service.name;
            item.dataset.serviceId = entry.service.id;
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                selectService(entry.service);
            });
            list.appendChild(item);
        }

        list.classList.remove('hidden');
    }

    function selectService(service) {
        const input = document.getElementById('task-service');
        const list = document.getElementById('service-suggestions');
        if (input) {
            input.value = service.name;
        }
        selectedServiceId = service.id;
        if (list) {
            list.classList.add('hidden');
        }
    }

    function settleServiceSelection() {
        const input = document.getElementById('task-service');
        if (!input) return;

        const value = normalizeText(input.value);
        const exact = services.find((service) => normalizeText(service.name) === value);
        if (exact) {
            selectedServiceId = exact.id;
            return;
        }
        selectedServiceId = null;
    }

    async function loadTasks() {
        try {
            const tasks = await apiRequest('/tasks');
            const statusMap = { 'Pending': 0, 'InProgress': 1, 'Completed': 2 };
            const priorityMap = { 'Low': 0, 'Medium': 1, 'High': 2, 'Urgent': 3 };
            const count = Math.min(tasks.length, TASK_INPUT_MAX);
            const serviceById = new Map(services.map((service) => [service.id, service.name]));

            memoryDataView.setUint32(taskInputPtr + 0, count, true);
            memoryDataView.setUint32(taskInputPtr + 4, TASK_INPUT_STRIDE, true);
            memoryDataView.setUint32(taskInputPtr + 8, 0, true);
            memoryDataView.setUint32(taskInputPtr + 12, 0, true);

            for (let i = 0; i < count; i++) {
                const task = tasks[i];
                const base = taskInputPtr + TASK_INPUT_HDR_SIZE + (i * TASK_INPUT_STRIDE);

                // Reserved/legacy numeric id (not used; UUID string is authoritative).
                memoryDataView.setUint32(base + 0, 0, true);
                memoryDataView.setUint32(base + 4, statusMap[task.status] || 0, true);
                memoryDataView.setUint32(base + 8, priorityMap[task.priority] || 0, true);

                writeFixedString(base + 12, task.id || '', TASK_ID_MAX);
                writeFixedString(base + 52, task.title || '', TASK_TITLE_MAX);
                writeFixedString(base + 180, task.description || '', TASK_DESC_MAX);
                writeFixedString(base + 692, task.category || '', TASK_CATEGORY_MAX);
                writeFixedString(base + 756, serviceById.get(task.service_id) || '', TASK_SERVICE_NAME_MAX);
                writeFixedString(base + 820, task.due_date ? task.due_date.split('T')[0] : '', TASK_DUE_DATE_MAX);
                writeFixedString(base + 852, task.assigned_to_name || '', TASK_ASSIGNED_TO_MAX);
            }

            instance.exports.ApplyTaskInputBuffer(count);
        } catch (err) {
            console.error('Failed to load tasks:', err);
        }
    }

    async function createTask(taskData) {
        try {
            await apiRequest('/tasks', {
                method: 'POST',
                body: JSON.stringify(taskData)
            });
            await loadTasks();
        } catch (err) {
            console.error('Failed to create task:', err);
            alert('Failed to create task');
        }
    }

    async function updateTask(taskId, taskData) {
        try {
            await apiRequest(`/tasks/${taskId}`, {
                method: 'PUT',
                body: JSON.stringify(taskData)
            });
            await loadTasks();
        } catch (err) {
            console.error('Failed to update task:', err);
            alert('Failed to update task');
        }
    }

    async function deleteTask(taskId) {
        try {
            await apiRequest(`/tasks/${taskId}`, {
                method: 'DELETE'
            });
            await loadTasks();
        } catch (err) {
            console.error('Failed to delete task:', err);
        }
    }

    // WebSocket
    function connectWebSocket() {
        if (wsConnection) {
            wsConnection.close();
        }

        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        wsConnection = new WebSocket(`${protocol}//${window.location.host}/api/ws`);

        wsConnection.onopen = () => {
            console.log('WebSocket connected');
            wsConnection.send(JSON.stringify({ type: 'subscribe' }));
        };

        wsConnection.onmessage = (event) => {
            const msg = JSON.parse(event.data);
            console.log('WS message:', msg);

            if (msg.type === 'task_created' || msg.type === 'task_updated' || msg.type === 'task_deleted') {
                if (instance?.exports?.SetDataDirtyPulse) {
                    instance.exports.SetDataDirtyPulse(0.35);
                }
                if (!wsReloadTimer) {
                    wsReloadTimer = setTimeout(async () => {
                        wsReloadTimer = null;
                        await loadTasks();
                    }, 200);
                }
            }
        };

        wsConnection.onclose = () => {
            console.log('WebSocket disconnected, reconnecting...');
            setTimeout(connectWebSocket, 3000);
        };

        wsConnection.onerror = (err) => {
            console.error('WebSocket error:', err);
        };
    }

    // Memory helpers
    function writeFixedString(address, str, maxLen) {
        const bytes = textEncoder.encode(str);
        const len = Math.min(bytes.length, Math.max(0, maxLen - 1));
        for (let i = 0; i < maxLen; i++) {
            memoryDataView.setUint8(address + i, 0);
        }
        for (let i = 0; i < len; i++) {
            memoryDataView.setUint8(address + i, bytes[i]);
        }
    }

    function resizeCanvasIfNeeded() {
        const canvas = window.canvasRoot;
        const scale = window.devicePixelRatio || 1;
        const pixelW = Math.max(1, Math.floor(window.innerWidth * scale));
        const pixelH = Math.max(1, Math.floor(window.innerHeight * scale));

        canvasScale = scale;
        if (pixelW !== canvasPixelWidth || pixelH !== canvasPixelHeight) {
            canvasPixelWidth = pixelW;
            canvasPixelHeight = pixelH;
            canvas.width = pixelW;
            canvas.height = pixelH;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
        }
    }

    // Canvas rendering
    function renderLoopCanvas() {
        let length = memoryDataView.getUint32(cmdBufferAddress + 0, true);
        const cmdSize = memoryDataView.getUint32(cmdBufferAddress + 4, true);
        let arrayOffset = memoryDataView.getUint32(cmdBufferAddress + 8, true);

        const canvas = window.canvasRoot;
        const ctx = window.canvasContext;
        const scale = canvasScale;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvasPixelWidth, canvasPixelHeight);

        const maxLen = Math.floor((CMD_BUFFER_BYTES - PACKED_HDR_SIZE) / PACKED_CMD_SIZE);
        if (length > maxLen) {
            length = maxLen;
        }

        hudCmds = length;
        hudTextCmds = 0;

        const stride = cmdSize || PACKED_CMD_SIZE;

        for (let i = 0; i < length; i++, arrayOffset += stride) {
            const commandType = memoryDataView.getUint8(arrayOffset + 0);
            const zIndex = memoryDataView.getInt16(arrayOffset + 2, true);
            const x = memoryDataView.getFloat32(arrayOffset + 4, true);
            const y = memoryDataView.getFloat32(arrayOffset + 8, true);
            const w = memoryDataView.getFloat32(arrayOffset + 12, true);
            const h = memoryDataView.getFloat32(arrayOffset + 16, true);

            switch (commandType) {
                case CLAY_RENDER_COMMAND_TYPE_RECTANGLE: {
                    const r = memoryDataView.getFloat32(arrayOffset + 20, true);
                    const g = memoryDataView.getFloat32(arrayOffset + 24, true);
                    const b = memoryDataView.getFloat32(arrayOffset + 28, true);
                    const a = memoryDataView.getFloat32(arrayOffset + 32, true);

                    const tl = memoryDataView.getFloat32(arrayOffset + 36, true);
                    const tr = memoryDataView.getFloat32(arrayOffset + 40, true);
                    const br = memoryDataView.getFloat32(arrayOffset + 44, true);
                    const bl = memoryDataView.getFloat32(arrayOffset + 48, true);

                    ctx.beginPath();
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                    ctx.roundRect(
                        x * scale,
                        y * scale,
                        w * scale,
                        h * scale,
                        [
                            tl * scale,
                            tr * scale,
                            br * scale,
                            bl * scale
                        ]
                    );
                    ctx.fill();
                    ctx.closePath();
                    break;
                }

                case CLAY_RENDER_COMMAND_TYPE_BORDER: {
                    const r = memoryDataView.getFloat32(arrayOffset + 20, true);
                    const g = memoryDataView.getFloat32(arrayOffset + 24, true);
                    const b = memoryDataView.getFloat32(arrayOffset + 28, true);
                    const a = memoryDataView.getFloat32(arrayOffset + 32, true);

                    const left = memoryDataView.getUint16(arrayOffset + 52, true);
                    const right = memoryDataView.getUint16(arrayOffset + 54, true);
                    const top = memoryDataView.getUint16(arrayOffset + 56, true);
                    const bottom = memoryDataView.getUint16(arrayOffset + 58, true);

                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;

                    // Top border
                    if (top > 0) {
                        ctx.lineWidth = top * scale;
                        ctx.beginPath();
                        ctx.moveTo(x * scale, (y + top / 2) * scale);
                        ctx.lineTo((x + w) * scale, (y + top / 2) * scale);
                        ctx.stroke();
                    }

                    // Bottom border
                    if (bottom > 0) {
                        ctx.lineWidth = bottom * scale;
                        ctx.beginPath();
                        ctx.moveTo(x * scale, (y + h - bottom / 2) * scale);
                        ctx.lineTo((x + w) * scale, (y + h - bottom / 2) * scale);
                        ctx.stroke();
                    }

                    // Left border
                    if (left > 0) {
                        ctx.lineWidth = left * scale;
                        ctx.beginPath();
                        ctx.moveTo((x + left / 2) * scale, y * scale);
                        ctx.lineTo((x + left / 2) * scale, (y + h) * scale);
                        ctx.stroke();
                    }

                    // Right border
                    if (right > 0) {
                        ctx.lineWidth = right * scale;
                        ctx.beginPath();
                        ctx.moveTo((x + w - right / 2) * scale, y * scale);
                        ctx.lineTo((x + w - right / 2) * scale, (y + h) * scale);
                        ctx.stroke();
                    }
                    break;
                }

                case CLAY_RENDER_COMMAND_TYPE_TEXT: {
                    hudTextCmds++;
                    const textPtr = memoryDataView.getUint32(arrayOffset + 20, true);
                    const textLen = memoryDataView.getUint32(arrayOffset + 24, true);
                    const fontId = memoryDataView.getUint16(arrayOffset + 28, true);
                    const fontSizeRaw = memoryDataView.getUint16(arrayOffset + 30, true);
                    const r = memoryDataView.getFloat32(arrayOffset + 36, true);
                    const g = memoryDataView.getFloat32(arrayOffset + 40, true);
                    const b = memoryDataView.getFloat32(arrayOffset + 44, true);
                    const a = memoryDataView.getFloat32(arrayOffset + 48, true);

                    const stringContents = new Uint8Array(memoryDataView.buffer, textPtr, textLen);
                    const text = textDecoder.decode(stringContents);
                    const fontSize = fontSizeRaw * GLOBAL_FONT_SCALING_FACTOR * scale;

                    ctx.font = `${fontSize}px ${fontsById[fontId] || 'sans-serif'}`;
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a / 255})`;
                    ctx.fillText(
                        text,
                        x * scale,
                        (y + h / 2) * scale
                    );
                    break;
                }

                case CLAY_RENDER_COMMAND_TYPE_SCISSOR_START: {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(
                        x * scale,
                        y * scale,
                        w * scale,
                        h * scale
                    );
                    ctx.clip();
                    ctx.closePath();
                    break;
                }

                case CLAY_RENDER_COMMAND_TYPE_SCISSOR_END: {
                    ctx.restore();
                    break;
            }
        }
    }

        if (hudEnabled) {
            const pad = 10 * scale;
            const w = 260 * scale;
            const h = 78 * scale;
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.55)';
            ctx.beginPath();
            ctx.roundRect(pad, pad, w, h, 10 * scale);
            ctx.fill();
            ctx.closePath();
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.font = `${12 * scale}px system-ui, -apple-system, sans-serif`;
            ctx.textBaseline = 'top';
            const line1 = `FPS ${hudFps.toFixed(1)} (min ${hudFpsMin.toFixed(1)})`;
            const line2 = `wasm ${hudWasmMs.toFixed(2)}ms  draw ${hudDrawMs.toFixed(2)}ms`;
            const line3 = `cmds ${hudCmds}  text ${hudTextCmds}`;
            ctx.fillText(line1, pad + 12 * scale, pad + 10 * scale);
            ctx.fillText(line2, pad + 12 * scale, pad + 28 * scale);
            ctx.fillText(line3, pad + 12 * scale, pad + 46 * scale);
            ctx.restore();
        }
    }

    // Position login inputs over Clay-rendered boxes
    function positionLoginInputs() {
        if (!instance) return;

        const usernameInput = document.getElementById('login-username');
        const passwordInput = document.getElementById('login-password');

        // Prefer Clay-derived rects when available; fall back to deterministic centering.
        if (instance.exports.GetLoginRect) {
            const rectPtrU = instance.exports.GetLoginRect(0);
            const rectPtrP = instance.exports.GetLoginRect(1);
            if (rectPtrU && rectPtrP) {
                const ux = memoryDataView.getFloat32(rectPtrU + 0, true);
                const uy = memoryDataView.getFloat32(rectPtrU + 4, true);
                const uw = memoryDataView.getFloat32(rectPtrU + 8, true);
                const uh = memoryDataView.getFloat32(rectPtrU + 12, true);

                const px = memoryDataView.getFloat32(rectPtrP + 0, true);
                const py = memoryDataView.getFloat32(rectPtrP + 4, true);
                const pw = memoryDataView.getFloat32(rectPtrP + 8, true);
                const ph = memoryDataView.getFloat32(rectPtrP + 12, true);

                const sane =
                    Number.isFinite(ux) && Number.isFinite(uy) && Number.isFinite(uw) && Number.isFinite(uh) &&
                    Number.isFinite(px) && Number.isFinite(py) && Number.isFinite(pw) && Number.isFinite(ph) &&
                    uw > 10 && uh > 10 && pw > 10 && ph > 10;

                if (sane) {
                    usernameInput.style.left = ux + 'px';
                    usernameInput.style.top = uy + 'px';
                    usernameInput.style.width = uw + 'px';
                    usernameInput.style.height = uh + 'px';

                    passwordInput.style.left = px + 'px';
                    passwordInput.style.top = py + 'px';
                    passwordInput.style.width = pw + 'px';
                    passwordInput.style.height = ph + 'px';
                    return;
                }
            }
        }

        const boxW = 400;
        const padX = 32;
        const inputW = boxW - padX * 2;
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        const left = Math.round(centerX - inputW / 2);
        const rowH = 44;
        const gap = 16;
        const topU = Math.round(centerY - rowH - gap / 2);
        const topP = Math.round(centerY + gap / 2);

        usernameInput.style.left = left + 'px';
        usernameInput.style.top = topU + 'px';
        usernameInput.style.width = inputW + 'px';
        usernameInput.style.height = rowH + 'px';

        passwordInput.style.left = left + 'px';
        passwordInput.style.top = topP + 'px';
        passwordInput.style.width = inputW + 'px';
        passwordInput.style.height = rowH + 'px';
    }

    // Main render loop
    function renderLoop(currentTime) {
        const elapsed = currentTime - previousFrameTime;
        previousFrameTime = currentTime;

        resizeCanvasIfNeeded();

        const wasmStart = performance.now();

        instance.exports.UpdateDrawFrame(
            cmdBufferAddress,
            window.innerWidth,
            window.innerHeight,
            window.mouseWheelXThisFrame || 0,
            window.mouseWheelYThisFrame || 0,
            window.mousePositionX || 0,
            window.mousePositionY || 0,
            window.touchDown || false,
            window.mouseDown || false,
            elapsed / 1000
        );

        hudWasmMs = performance.now() - wasmStart;

        const drawStart = performance.now();

        renderLoopCanvas();

        hudDrawMs = performance.now() - drawStart;

        // FPS aggregation
        const fpsNow = elapsed > 0 ? (1000 / elapsed) : 0;
        hudAccumMs += elapsed;
        hudFrames += 1;
        if (fpsNow > 0) {
            hudFpsMin = Math.min(hudFpsMin, fpsNow);
        }
        if (currentTime - hudLastReportTime >= 500) {
            const avgFps = hudAccumMs > 0 ? (hudFrames * 1000 / hudAccumMs) : 0;
            hudFps = hudFps ? (hudFps * 0.5 + avgFps * 0.5) : avgFps;
            hudAccumMs = 0;
            hudFrames = 0;
            hudLastReportTime = currentTime;
            hudFpsMin = 999;
        }

        // Check if we need to show create modal
        if (instance.exports.GetShowCreateModal()) {
            let serviceIndex = -1;
            if (instance.exports.GetPendingCreateServiceIndex) {
                serviceIndex = instance.exports.GetPendingCreateServiceIndex();
            }
            showCreateModal(serviceIndex);
        }

        // Position login inputs if on login screen
        if (!authToken) {
            positionLoginInputs();
        }

        requestAnimationFrame(renderLoop);
        window.mouseDown = false;
    }

    // Modal functions
    function showCreateModal(serviceIndex = -1) {
        document.getElementById('task-modal').classList.remove('hidden');
        document.getElementById('modal-title').textContent = 'Create Task';
        document.getElementById('submit-btn').textContent = 'Create';
        document.getElementById('task-form').reset();
        selectedServiceId = null;
        const serviceInput = document.getElementById('task-service');
        if (serviceInput) {
            if (serviceIndex >= 0 && serviceIndex < services.length) {
                const service = services[serviceIndex];
                serviceInput.value = service.name;
                selectedServiceId = service.id;
            } else {
                serviceInput.value = '';
            }
            renderServiceSuggestions(serviceInput.value);
        }
        if (instance?.exports?.SetCreatePanelVisible) {
            instance.exports.SetCreatePanelVisible(true);
        }
    }

    function hideModal() {
        document.getElementById('task-modal').classList.add('hidden');
        const list = document.getElementById('service-suggestions');
        if (list) {
            list.classList.add('hidden');
        }
        if (instance?.exports?.SetCreatePanelVisible) {
            instance.exports.SetCreatePanelVisible(false);
        }
    }

    // Initialize
    async function init() {
        window.canvasRoot = document.getElementById('canvas');
        window.canvasContext = window.canvasRoot.getContext('2d');
        window.mousePositionX = 0;
        window.mousePositionY = 0;
        window.mouseWheelXThisFrame = 0;
        window.mouseWheelYThisFrame = 0;
        window.touchDown = false;
        window.mouseDown = false;

        let loginFocusInitialized = false;

        // Event listeners
        let wheelTimeout = null;
        document.addEventListener('wheel', (e) => {
            window.mouseWheelXThisFrame = e.deltaX * -0.1;
            window.mouseWheelYThisFrame = e.deltaY * -0.1;
            clearTimeout(wheelTimeout);
            wheelTimeout = setTimeout(() => {
                window.mouseWheelXThisFrame = 0;
                window.mouseWheelYThisFrame = 0;
            }, 10);
        });

        document.addEventListener('mousemove', (e) => {
            window.mousePositionX = e.clientX;
            window.mousePositionY = e.clientY;
        });

        document.addEventListener('mousedown', () => {
            window.mouseDown = true;
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'F2') {
                hudEnabled = !hudEnabled;
            }

            // Clay debug toggle: Ctrl+D (avoid browser-reserved keys like F3 search)
            if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D')) {
                e.preventDefault();
                if (instance?.exports?.Clay_IsDebugModeEnabled && instance?.exports?.Clay_SetDebugModeEnabled) {
                    const enabled = instance.exports.Clay_IsDebugModeEnabled();
                    instance.exports.Clay_SetDebugModeEnabled(!enabled);
                }
            }
        });

        document.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                window.touchDown = true;
                window.mousePositionX = e.touches[0].clientX;
                window.mousePositionY = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                window.mousePositionX = e.touches[0].clientX;
                window.mousePositionY = e.touches[0].clientY;
            }
        });

        document.addEventListener('touchend', () => {
            window.touchDown = false;
        });

        // Login form handling
        document.getElementById('login-username').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('login-password').focus();
            }
        });
        document.getElementById('login-password').addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const username = document.getElementById('login-username').value;
                const password = document.getElementById('login-password').value;
                if (username && password) {
                    await login(username, password);
                }
            }
        });

        // Task form handling
        const serviceInput = document.getElementById('task-service');
        if (serviceInput) {
            serviceInput.addEventListener('input', (e) => {
                selectedServiceId = null;
                renderServiceSuggestions(e.target.value);
            });
            serviceInput.addEventListener('focus', (e) => {
                renderServiceSuggestions(e.target.value);
            });
            serviceInput.addEventListener('blur', () => {
                settleServiceSelection();
                setTimeout(() => {
                    const list = document.getElementById('service-suggestions');
                    if (list) {
                        list.classList.add('hidden');
                    }
                }, 150);
            });
        }

        document.getElementById('task-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            const statusMap = ['Pending', 'InProgress', 'Completed'];
            const priorityMap = ['Low', 'Medium', 'High', 'Urgent'];

            const taskData = {
                title: document.getElementById('task-title').value,
                description: document.getElementById('task-description').value || null,
                status: statusMap[parseInt(document.getElementById('task-status').value)],
                priority: priorityMap[parseInt(document.getElementById('task-priority').value)],
                category: null,
                service_id: selectedServiceId,
                due_date: document.getElementById('task-due-date').value || null
            };

            await createTask(taskData);
            hideModal();
        });

        document.getElementById('cancel-btn').addEventListener('click', hideModal);

        // Load WASM
        const importObject = {
            clay: {
                measureTextFunction: (addressOfDimensions, textToMeasure, addressOfConfig) => {
                    const stringLength = memoryDataView.getUint32(textToMeasure, true);
                    const pointerToString = memoryDataView.getUint32(textToMeasure + 4, true);

                    // Clay_TextElementConfig layout (wasm32):
                    // +0  u32 userData ptr
                    // +4  Clay_Color (4 f32)
                    // +20 u16 fontId
                    // +22 u16 fontSize
                    const fontId = memoryDataView.getUint16(addressOfConfig + 20, true);
                    const fontSize = memoryDataView.getUint16(addressOfConfig + 22, true);

                    const bytes = new Uint8Array(memoryDataView.buffer, pointerToString, stringLength);
                    const text = textDecoder.decode(bytes);
                    const dimensions = getTextDimensions(
                        text,
                        `${Math.round(fontSize * GLOBAL_FONT_SCALING_FACTOR)}px ${fontsById[fontId] || 'sans-serif'}`
                    );
                    memoryDataView.setFloat32(addressOfDimensions, dimensions.width, true);
                    memoryDataView.setFloat32(addressOfDimensions + 4, dimensions.height, true);
                },

                // Clay declares this import for optional external scroll handling.
                // We don't use external scroll handling, but the import must exist for instantiation.
                queryScrollOffsetFunction: (..._args) => 0n,
            }
        };

        // Avoid stale WASM during rapid iteration.
        const wasmUrl = `./app.wasm?cachebust=${Date.now()}`;
        const { instance: wasmInstance } = await WebAssembly.instantiateStreaming(
            fetch(wasmUrl, { cache: 'no-store' }),
            importObject
        );

        instance = wasmInstance;
        memoryDataView = new DataView(new Uint8Array(instance.exports.memory.buffer).buffer);
        scratchSpaceAddress = instance.exports.__heap_base.value;
        heapSpaceAddress = scratchSpaceAddress + 1024;

        // Initialize Clay
        const arenaAddress = scratchSpaceAddress;
        const memorySize = instance.exports.Clay_MinMemorySize();
        instance.exports.Clay_CreateArenaWithCapacityAndMemory(arenaAddress, memorySize, heapSpaceAddress);
        instance.exports.Clay_Initialize(arenaAddress);

        // Reserve space for packed render commands; use the following region as scratch arena.
        cmdBufferAddress = heapSpaceAddress + memorySize;
        instance.exports.SetScratchMemory(cmdBufferAddress + CMD_BUFFER_BYTES);

        // Initialize app
        instance.exports.InitApp();
        appStatePtr = instance.exports.GetAppState();
        taskInputPtr = instance.exports.GetTaskInputBuffer();
        serviceInputPtr = instance.exports.GetServiceInputBuffer();
        currentUserPtr = instance.exports.GetCurrentUserBuffer();

        resizeCanvasIfNeeded();

        // Dev mode: skip login, go straight to tasks.
        try {
            await withDailyLoadingOverlay(async () => {
                await loadServices();
                await loadTasks();
            });
        } catch (_err) {
            // Ignore; backend may be down during frontend iteration.
        }
        instance.exports.SetLoggedIn(true);
        document.getElementById('login-overlay').classList.add('hidden');
        connectWebSocket();

        // Login overlay is disabled in dev mode.

        // Start render loop
        // Position login inputs immediately (before first frame) if needed.
        if (!authToken) {
            positionLoginInputs();
        }
        requestAnimationFrame(renderLoop);
    }

    init();
</script>
</body>
</html>
